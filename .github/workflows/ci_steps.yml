# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) Contributors to the OpenEXR Project.

# These are the steps for all CI jobs. Linux, macOS, and Windows all
# share a common set of configure/build/validate steps.  The input
# variables control all variations of the jobs.
#
# Each job validates that the proper files are installed by comparing
# the install_manifest.txt to a reference for that job. This requires
# that each job have a corresponding reference, and that thes
# references are updated when any change is made to the installation
# headers/libraries/cmake/etc.

name: CI Steps

on:
  workflow_call:
    # This inputs receive values via the "with:" section in ci_workflow.yml
    inputs:
      build:
        type: string
      os:
        type: string
      container:
        type: string
      cxx-standard:
        type: string
      cxx-compiler:
        type: string
      cc-compiler:
        type: string
      build-type:
        type: string

      msystem:
        type: string
      python:
        type: string
      pybind11:
        type: string
      IMATH_INSTALL_PKG_CONFIG:
        type: string
      BUILD_SHARED_LIBS:
        type: string
      BUILD_TESTING:
        type: string
      namespace:
        type: string
      validate_install:
        type: string

jobs:
  steps:
    runs-on: ${{ inputs.os }}

    continue-on-error: true
    
#    container:
#      image: ${{ inputs.container }}

    env:
      CXX: ${{ inputs.cxx-compiler }}
      CC: ${{ inputs.cc-compiler }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Install MSYS2 ${{ inputs.msystem }}
        if: inputs.msystem != ''
        uses: msys2/setup-msys2@61f9e5e925871ba6c9e3e8da24ede83ea27fa91f # v2.27.0
        with:
          msystem: ${{ inputs.msystem }}
          update: true
          install: git
          pacboy: cc:p cmake:p

      - name: Create build directories
      
        run: mkdir _install _build _examples _python
        shell: bash


      - name: Install Python Dependencies
        if: inputs.python == 'ON' || inputs.pybind11 == 'ON'
        run: |
          python -m pip install --upgrade pip "numpy<2" conan
          echo "PYTHON_INSTALL_DIR=${{ github.workspace }}/_python" >> $GITHUB_ENV
          echo "PYTHONPATH=${{ github.workspace }}/_python" >> $GITHUB_ENV
          PYTHON_EXECUTABLE=$(which python)
          echo "PYTHON_EXECUTABLE=${PYTHON_EXECUTABLE}" >> $GITHUB_ENV
        shell: bash

      - name: Set Up Conan
        if: inputs.python == 'ON'
        run: |
          CONAN_ROOT="${PWD}/_conan"
          TOOLCHAIN_CONF="tools.cmake.cmaketoolchain:generator=Ninja"
          conan profile detect --force
          conan_args=("."
                      "--output-folder="${CONAN_ROOT}""
                      "--build=missing"
                      "--settings" "build_type=${{ inputs.build-type }}")
          #if [[ "$RUNNER_OS" == "Windows" ]]; then
          #  if [[ "$CC" == "cl" || "$CXX" == "cl" || "${compiler}" == "msvc" ]]; then
          #    TOOLCHAIN_CONF=""
          #  fi
          #  if [[ "${{ inputs.msystem }}" == "MINGW32" || "${{ inputs.msystem }}" == "UCRT64" ]]; then
          #    conan_args+=("--settings" "compiler=gcc")
          #  fi
          #else
          #  conan_args+=("${TOOLCHAIN_CONF:+-c ${TOOLCHAIN_CONF}}")
          #fi
          echo conan install "${conan_args[@]}" 
          conan install "${conan_args[@]}" 
          echo "CONAN_ROOT=${CONAN_ROOT}" >> $GITHUB_ENV
          echo "CMAKE_TOOLCHAIN_FILE=${CONAN_ROOT}/conan_toolchain.cmake" >> $GITHUB_ENV
        shell: bash

      - name: Set Up Environment
        if: inputs.python == 'ON'
        run: |
          echo "Boost_ROOT=${CONAN_ROOT}" >> $GITHUB_ENV
        shell: bash

      - name: Install pybind11
        if: inputs.pybind11 == 'ON'
        run: |
          pip install pybind11
          pybind11_DIR=$(python -c 'import pybind11; print(pybind11.get_cmake_dir())')
          echo "pybind11_DIR=${pybind11_DIR}" >> $GITHUB_ENV
        shell: bash

      - name: Construct CMake command
        run: |
          # Construct the cmake command as a variable, so the
          # Configure step below can execute it, but also so we can store
          # in in the install_manifest as a debugging reference
          cmake_args=("-B" "." "-S" "..")
          cmake_args+=("-DCMAKE_INSTALL_PREFIX=../_install")
          cmake_args+=("-DCMAKE_BUILD_TYPE=${{ inputs.build-type }}")
          cmake_args+=("-DCMAKE_CXX_STANDARD=${{ inputs.cxx-standard }}")
          cmake_args+=("-DBUILD_SHARED_LIBS=${{ inputs.BUILD_SHARED_LIBS }}")
          cmake_args+=("-DIMATH_INSTALL_PKG_CONFIG=${{ inputs.IMATH_INSTALL_PKG_CONFIG }}")
          cmake_args+=("-DBUILD_TESTING=${{ inputs.BUILD_TESTING }}")
          cmake_args+=("-DPYTHON=${{ inputs.python }}")
          cmake_args+=("-DPYBIND11=${{ inputs.pybind11 }}")
          cmake_args+=("-DCMAKE_VERBOSE_MAKEFILE=ON")
          if [ -n "${{ env.PYTHON_EXECUTABLE }}" ]; then
              cmake_args+=("-DPython3_EXECUTABLE=${{ env.PYTHON_EXECUTABLE }}")
          fi
          if [ -n "${{ env.PYTHON_INSTALL_DIR }}" ]; then
              cmake_args+=("-DPYTHON_INSTALL_DIR=${{ env.PYTHON_INSTALL_DIR }}")
          fi
          if [ -n "${{ env.pybind11_DIR }}" ]; then
              cmake_args+=("-Dpybind11_DIR=${{ env.pybind11_DIR }}")
          fi
          if [ -n "${{ env.Boost_ROOT }}" ]; then
              cmake_args+=("-DBoost_ROOT=${{ env.Boost_ROOT }}")
          fi
          if [ -n "${{ env.CMAKE_TOOLCHAIN_FILE }}" ]; then
              cmake_args+=("-DCMAKE_TOOLCHAIN_FILE=${{ env.CMAKE_TOOLCHAIN_FILE }}")
          fi
          # On Windows, Conan requires CMP0091, which controls how CMAKE_MSVC_RUNTIME_LIBRARY is set
          if [[ "$RUNNER_OS" == "Windows" ]]; then
              cmake_args+=("-DCMAKE_POLICY_DEFAULT_CMP0091=NEW")
          fi
          if [ -n "${{ inputs.namespace }}" ]; then
              cmake_args+=("-DIMATH_NAMESPACE=${{ inputs.namespace }}")
          fi
          if [[ "${{ inputs.msystem }}" == "MINGW32" || "${{ inputs.msystem }}" == "UCRT64" ]]; then
              cmake_args+=("-DCMAKE_C_COMPILER=gcc")
              cmake_args+=("-DCMAKE_CXX_COMPILER=g++")
          fi
          quoted_args=$(printf '%q ' "${cmake_args[@]}")
          echo "CMAKE_ARGS=$quoted_args" >> $GITHUB_ENV

          # Remove the os version from the manifest name, so it only
          # contains "ubuntu", "macos", or "windows", so the name is,
          # e.g. install_manifest.macos.1.txt
          echo "INSTALL_MANIFEST=$(echo 'install_manifest.${{ inputs.os }}' | cut -d'-' -f1).${{ inputs.build }}.txt" >> $GITHUB_ENV
        working-directory: _build
        shell: bash

      - name: Configure, Build, Test
        if: inputs.msystem == ''
        run: |
          cmake --version
          cmake ${{ env.CMAKE_ARGS }}
          cmake --build . --target install --config ${{ inputs.build-type }}
          if [ "${{ inputs.BUILD_TESTING }}" == "ON" ]; then
            echo ctest -T Test -C ${{ inputs.build-type }} --timeout 7200 --output-on-failure -VV
          fi
        working-directory: _build
        shell: bash

      - name: Configure, Build, Test (msys2) # requires msys2 shell
        if: inputs.msystem != ''
        run: |
          cmake --version
          cmake ${{ env.CMAKE_ARGS }}
          cmake --build . --target install --config ${{ inputs.build-type }}
          if [ "${{ inputs.BUILD_TESTING }}" == "ON" ]; then
            echo ctest -T Test -C ${{ inputs.build-type }} --timeout 7200 --output-on-failure -VV
          fi
        working-directory: _build
        shell: msys2 {0}

      - name: Test Pybind11
        if: inputs.pybind11 == 'ON'
        run: python -v src/pybind11/PyBindImathTest/test_import_pybindimath.py
        shell: bash

      - name: Test Python
        if: inputs.python == 'ON'
        run: |
          python -v src/python/PyImathTest/test_import_imath.py
          python -v src/python/PyImathNumpyTest/test_import_imathnumpy.py
        shell: bash

      - name: Prepare install_manifest
        # Store the cmake command as the first line of the manifest,
        # and remove the path prefix, so the manifest contains only
        # the local filenames.
        run: |
          echo "# cmake ${{ env.CMAKE_ARGS }}" > "_build/$INSTALL_MANIFEST"
          sort _build/install_manifest.txt | sed -e "s:^.*/_install/::" >> "_build/$INSTALL_MANIFEST"
        shell: bash

      - name: Upload install_manifest.txt
        # Upload the manifest to make it possible to download for inspection and debugging
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.INSTALL_MANIFEST }}
          path: _build/${{ env.INSTALL_MANIFEST }}

      - name: Validate install
        if: inputs.validate_install == 'ON'
        # Validate that the build has installed the proper files by comparing against the appropriate reference manifest
        run: |
          share/ci/scripts/validate_install.py "_build/$INSTALL_MANIFEST" "share/ci/install_manifest/$INSTALL_MANIFEST" _build/CMakeCache.txt
        shell: bash

      - name: Test standalone
        if: inputs.msystem == ''
        run: |
          # Make sure we can build the tests when configured as a
          # standalone application linking against the just-installed
          # Imath library.
          cmake_args=("../src/ImathTest")
          cmake_args+=("-DCMAKE_PREFIX_PATH=../../_install")
          cmake_args+=("-DCMAKE_BUILD_TYPE=${{ inputs.build-type }}")
          cmake_args+=("-DCMAKE_CXX_STANDARD=${{ inputs.cxx-standard }}")
          cmake_args+=("-DCMAKE_CXX_FLAGS=${{ inputs.cxx-flags }}")
          if [[ "$RUNNER_OS" == "Windows" ]]; then
              cmake_args+=("-DCMAKE_POLICY_DEFAULT_CMP0091=NEW")
          fi
          if [ -n "${{ env.CMAKE_TOOLCHAIN_FILE }}" ]; then
              cmake_args+=("-DCMAKE_TOOLCHAIN_FILE=${{ env.CMAKE_TOOLCHAIN_FILE }}")
          fi
          quoted_args=$(printf '%q ' "${cmake_args[@]}")
          cmake $quoted_args
          cmake --build . \
                --config ${{ inputs.build-type }}

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            ./bin/"${{ inputs.build-type }}"/ImathTest.exe || true
          else
            ./bin/ImathTest
          fi
        shell: bash
        working-directory: _examples

      - name: Examples
        # The example code use the Imath:: namespace explicitly, they won't work with a custom namespace, so skip the test in that case.
        if: inputs.namespace == '' && inputs.msystem == ''
        run: |
          # Confirm the examples compile and execute
          rm -rf bin CMakeCache.txt CMakeFiles cmake_install.cmake Makefile
          cmake_args=("../website/examples")
          cmake_args+=("-DCMAKE_PREFIX_PATH=../../_install")
          cmake_args+=("-DCMAKE_BUILD_TYPE=${{ inputs.build-type }}")
          cmake_args+=("-DCMAKE_CXX_STANDARD=${{ inputs.cxx-standard }}")
          # On Windows, Conan requires CMP0091, which controls how CMAKE_MSVC_RUNTIME_LIBRARY is set
          if [[ "$RUNNER_OS" == "Windows" ]]; then
              cmake_args+=("-DCMAKE_POLICY_DEFAULT_CMP0091=NEW")
          fi
          if [ -n "${{ env.CMAKE_TOOLCHAIN_FILE }}" ]; then
              cmake_args+=("-DCMAKE_TOOLCHAIN_FILE=${{ env.CMAKE_TOOLCHAIN_FILE }}")
          fi
          quoted_args=$(printf '%q ' "${cmake_args[@]}")
          cmake $quoted_args
          cmake --build . --config ${{ inputs.build-type }}

          if [[ "$RUNNER_OS" == "Windows" ]]; then
            ./bin/"${{ inputs.build-type }}"/imath-intro.exe || true
            ./bin/"${{ inputs.build-type }}"/imath-examples.exe || true
          else
            ./bin/imath-intro
            ./bin/imath-examples
          fi
        shell: bash
        working-directory: _examples

      - name: Examples (msys2)
        # The example code use the Imath:: namespace explicitly, they won't work with a custom namespace, so skip the test in that case.
        if: inputs.namespace == '' && inputs.msystem != ''
        run: |
          # Confirm the examples compile and execute
          rm -rf bin CMakeCache.txt CMakeFiles cmake_install.cmake Makefile
          cmake_args=("../website/examples")
          cmake_args+=("-DCMAKE_PREFIX_PATH=../../_install")
          cmake_args+=("-DCMAKE_BUILD_TYPE=${{ inputs.build-type }}")
          cmake_args+=("-DCMAKE_CXX_STANDARD=${{ inputs.cxx-standard }}")
          # On Windows, Conan requires CMP0091, which controls how CMAKE_MSVC_RUNTIME_LIBRARY is set
          if [[ "$RUNNER_OS" == "Windows" ]]; then
              cmake_args+=("-DCMAKE_POLICY_DEFAULT_CMP0091=NEW")
          fi
          if [ -n "${{ env.CMAKE_TOOLCHAIN_FILE }}" ]; then
              cmake_args+=("-DCMAKE_TOOLCHAIN_FILE=${{ env.CMAKE_TOOLCHAIN_FILE }}")
          fi
          quoted_args=$(printf '%q ' "${cmake_args[@]}")
          cmake $quoted_args
          cmake --build . --config ${{ inputs.build-type }}
          export PATH="${{ github.workspace }}/_install/bin:$PATH"
          ./bin/imath-intro.exe
          ./bin/imath-examples.exe
        shell: msys2 {0}
        working-directory: _examples

